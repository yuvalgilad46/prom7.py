# Import necessary libraries
import math

import numpy as np
import matplotlib
from numpy.ma.core import floor
from scipy.spatial.transform import Rotation
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.animation as animation
import traceback
from matplotlib.widgets import Button
from scipy.integrate import RK45


# Removed scipy.differentiate import as it wasn't used

# --- Quaternion Class (Mostly Unchanged) ---
class Quaternion:
    """Represents a quaternion for 3D rotations."""
    def __init__(self, w, x, y, z):
        # Ensure components are floats for consistency
        self.w = float(w)
        self.x = float(x)
        self.y = float(y)
        self.z = float(z)

    def __repr__(self):
        # Corrected f-string formatting and typo
        return f"Q(w={self.w:.3f}, x={self.x:.3f}, y={self.y:.3f}, z={self.z:.3f})"

    def __mul__(self, other):
        """Quaternion multiplication or scalar multiplication."""
        if isinstance(other, Quaternion):
            w = self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z
            x = self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y
            y = self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x
            z = self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
            return Quaternion(w, x, y, z)
        elif isinstance(other, (int, float, np.number)):
            return Quaternion(self.w * other, self.x * other, self.y * other, self.z * other)
        else:
            # Allow multiplication by numpy arrays component-wise (useful for derivatives)
            if isinstance(other, (np.ndarray, list)) and len(other) == 4:
                 return Quaternion(self.w * other[0], self.x * other[1], self.y * other[2], self.z * other[3])
            raise TypeError(f"Multiplication only supports Quaternion, scalar, or 4-element array/list, not {type(other)}")

    def __add__(self, other):
        """Quaternion addition."""
        if isinstance(other, Quaternion):
            return Quaternion(self.w + other.w, self.x + other.x, self.y + other.y, self.z + other.z)
        # Allow addition with 4-element lists/arrays (useful for RK4 steps)
        elif isinstance(other, (np.ndarray, list)) and len(other) == 4:
             return Quaternion(self.w + other[0], self.x + other[1], self.y + other[2], self.z + other[3])
        else:
            raise TypeError(f"Addition only supports two Quaternions or Quaternion and 4-element array/list, not {type(other)}")

    def conjugate(self):
        """Returns the conjugate of the quaternion."""
        return Quaternion(self.w, -self.x, -self.y, -self.z)

    def norm_sq(self):
        """Calculates the squared norm (magnitude squared)."""
        return self.w**2 + self.x**2 + self.y**2 + self.z**2

    def norm(self):
        """Calculates the norm (magnitude) of the quaternion."""
        return np.sqrt(self.norm_sq())

    def normalize(self):
        """Normalizes the quaternion to unit length."""
        n = self.norm()
        if n < 1e-9:
            # print("Warning: Normalizing near-zero quaternion. Returning identity.")
            return Quaternion.identity() # Use static method
        inv_n = 1.0 / n
        self.w *= inv_n
        self.x *= inv_n
        self.y *= inv_n
        self.z *= inv_n
        return self # Return self for chaining if needed, but modifies in place

    def to_rotation_matrix(self):
        """Converts the unit quaternion to a 3x3 rotation matrix."""
        # It's assumed the quaternion is already normalized for physics updates
        w, x, y, z = self.w, self.x, self.y, self.z
        x2, y2, z2 = x * x, y * y, z * z
        wx, wy, wz = w * x, w * y, w * z
        xy, xz, yz = x * y, x * z, y * z

        R = np.array([
            [1 - 2 * y2 - 2 * z2, 2 * xy - 2 * wz, 2 * xz + 2 * wy],
            [2 * xy + 2 * wz, 1 - 2 * x2 - 2 * z2, 2 * yz - 2 * wx],
            [2 * xz - 2 * wy, 2 * yz + 2 * wx, 1 - 2 * x2 - 2 * y2]
        ], dtype=float) # Ensure float type
        return R

    def rotate_vector(self, v):
        """Rotates a 3D vector using the quaternion (q * v * q_conj)."""
        v = np.asarray(v, dtype=float)
        if v.shape != (3,):
            raise ValueError("Input vector must be 3D")
        v_quat = Quaternion(0.0, v[0], v[1], v[2])
        # Assume normalized for performance, or uncomment below
        # q_norm = self.normalize() # Creates copy if normalize returns new Q
        rotated_v_quat = self * v_quat * self.conjugate()
        return np.array([rotated_v_quat.x, rotated_v_quat.y, rotated_v_quat.z])

    def to_list(self):
         """Return quaternion components as a list."""
         return [self.w, self.x, self.y, self.z]

    @staticmethod
    def identity():
        """Returns the identity quaternion."""
        return Quaternion(1.0, 0.0, 0.0, 0.0)

# --- Base Rigid Body Class ---
class RigidBody:
    def __init__(self, obj_id, obj_type, pos, vel, quat, ang_vel, mass):
        self.id = obj_id # Unique identifier
        self.obj_type = obj_type # 'sphere', 'cylinder', etc.
        self.pos = np.asarray(pos, dtype=float) # This is the CM position
        self.vel = np.asarray(vel, dtype=float)
        self.quat = quat if isinstance(quat, Quaternion) else Quaternion(*quat)
        self.ang_vel = np.asarray(ang_vel, dtype=float) # World frame
        self.mass = float(mass)
        self.inv_mass = 1.0 / mass if mass > 0 else 0.0

        # Inertia properties to be set by subclasses
        self.inertia_local = np.zeros((3, 3))
        self.inv_inertia_local = np.zeros((3, 3))
        self.inv_inertia_world = np.zeros((3, 3))
        self.update_inv_inertia_world() # Initial calculation

    def update_inv_inertia_world(self):
        """Calculates the inverse inertia tensor in world coordinates"""
        R = self.quat.to_rotation_matrix()
        self.inv_inertia_world = R @ self.inv_inertia_local @ R.T

    def get_state_vector(self):
        """Return current state as a numpy vector (pos, vel, quat_list, ang_vel)."""
        return np.concatenate([
            self.pos,
            self.vel,
            self.quat.to_list(),
            self.ang_vel
        ])

    def set_state_from_vector(self, vec):
        """Update state from a numpy vector."""
        self.pos = vec[0:3]
        self.vel = vec[3:6]
        self.quat = Quaternion(*vec[6:10])
        self.ang_vel = vec[10:13]
        # Ensure quaternion is normalized after update
        self.quat.normalize()
        # Update world inertia tensor as orientation changed
        self.update_inv_inertia_world()

    def __repr__(self):
        # Base representation
         return f"{self.obj_type.capitalize()}(id={self.id}, pos={self.pos}, vel={self.vel}, quat={self.quat}, ang_vel={self.ang_vel})"

# --- Ball Class ---
class Ball(RigidBody):
    def __init__(self, obj_id, pos, vel, quat, ang_vel, radius, mass):
        super().__init__(obj_id, 'sphere', pos, vel, quat, ang_vel, mass)
        self.radius = float(radius)
        self.height = float(radius) # Use radius as height for sphere bounding
        self._calculate_inertia()
        self.update_inv_inertia_world() # Recalculate with correct local inertia

    def _calculate_inertia(self):
        if self.mass > 0 and self.radius > 0:
            I_scalar = (2.0 / 5.0) * self.mass * self.radius**2
            self.inertia_local = np.diag([I_scalar] * 3)
            self.inv_inertia_local = np.diag([1.0 / I_scalar] * 3)
        else:
            self.inertia_local = np.eye(3) # Prevent division by zero
            self.inv_inertia_local = np.eye(3)

    # Override repr for specific details if needed
    # def __repr__(self):
    #     base_repr = super().__repr__()
    #     return f"{base_repr[:-1]}, radius={self.radius})"


# --- Pin Class ---
class Pin(RigidBody):
    def __init__(self, obj_id, pos, vel, quat, ang_vel, radius, height, mass):
        # Note: pos here is the Center of Mass position, not the base position
        super().__init__(obj_id, 'cylinder', pos, vel, quat, ang_vel, mass)
        self.radius = float(radius)
        self.height = float(height)
        self._calculate_inertia() # Calculate inertia about the new CM
        self.update_inv_inertia_world() # Recalculate with correct local inertia

        # Define local coordinates of the bottom and top caps relative to the CM
        self.local_bottom_cap_z = -self.height / 3.0
        self.local_top_cap_z = 2.0 * self.height / 3.0


    def _calculate_inertia(self):
        """Calculates the inertia tensor about the center of mass (1/3 height from base)."""
        if self.mass > 0 and self.radius > 0 and self.height > 0:
            # Inertia about the geometric center (standard formula)
            Ixy_geometric = (1.0 / 12.0) * self.mass * (3 * self.radius**2 + self.height**2)
            Iz_geometric = (1.0 / 2.0) * self.mass * self.radius**2

            # Distance from geometric center (1/2 height) to new CM (1/3 height)
            # The vector from geometric center to new CM is [0, 0, 1/3*h - 1/2*h] = [0, 0, -1/6*h] in local frame
            distance_sq = (self.height / 6.0)**2

            # Apply Parallel Axis Theorem: I_new = I_old + m * (r^2 * I - r * r^T)
            # For diagonal inertia tensor and displacement along z-axis [0, 0, dz]:
            # Ixx_new = Ixx_old + m * dz^2
            # Iyy_new = Iyy_old + m * dz^2
            # Izz_new = Izz_old (axis of rotation is parallel to displacement)

            Ixx_new = Ixy_geometric + self.mass * distance_sq
            Iyy_new = Ixy_geometric + self.mass * distance_sq
            Izz_new = Iz_geometric # Izz is unchanged

            self.inertia_local = np.diag([Ixx_new, Iyy_new, Izz_new])

            try:
                self.inv_inertia_local = np.linalg.inv(self.inertia_local)
            except np.linalg.LinAlgError:
                print(f"Warning: Pin {self.id} inertia tensor is singular. Using pseudo-inverse.")
                self.inv_inertia_local = np.linalg.pinv(self.inertia_local)
        else:
             self.inertia_local = np.eye(3)
             self.inv_inertia_local = np.eye(3) # Prevent issues

    def get_vertices(self, n_sides=12):
        """ Calculates world coordinates of top and bottom cap vertices relative to the CM. """
        R = self.quat.to_rotation_matrix()
        vertices = {'top': [], 'bottom': []}
        for i in range(n_sides):
            angle = 2 * np.pi * i / n_sides
            # Local coordinates (relative to the NEW center of mass)
            local_top = np.array([self.radius * np.cos(angle), self.radius * np.sin(angle), self.local_top_cap_z])
            local_bottom = np.array([self.radius * np.cos(angle), self.radius * np.sin(angle), self.local_bottom_cap_z])
            # Convert to world coordinates
            vertices['top'].append(self.pos + R @ local_top)
            vertices['bottom'].append(self.pos + R @ local_bottom)
        return vertices


# --- Simulation Parameters ---
DT = 0.01
NUM_FRAMES = 500 # Increased frames
COLLISION_EPSILON = 0.7 # Slightly less bouncy
GRAVITY = np.array([0.0, 0.0, -9.81])
FLOOR_RESTITUTION_BALL = 0.5 # How much bounce off the floor
FLOOR_RESTITUTION_PIN = 0.2
FLOOR_FRICTION_COEFF = 0.35 # Coefficient of kinetic friction
EARTH_RADIUS = 6371000 # Unused
EARTH_MASS = 5.972168 * math.pow(10,24) # Unused
is_paused = False

# --- Initial States & Objects ---
ball_1 = Ball(obj_id='ball_1',
              pos=np.array([-1.5, 0, 0.109]), # Start touching floor (CM at radius)
              vel=np.array([8.0, 0.1, 0.0]),    # Faster initial speed
              quat=Quaternion.identity(),
              ang_vel=np.array([0.0, 0.0, 0.0]), # Maybe add initial spin later
              radius=0.109,
              mass= 5.0)

pins = []
# Standard 10-pin setup (approximate positions relative to origin (0,0))
# Distances are roughly: Row separation ~ sqrt(3)*PinDiam, Pin separation in row ~ 1.0*PinDiam
pin_radius = 0.06
pin_height = 0.38
pin_diam = 2 * pin_radius
row_sep = 0.3 # Adjusted spacing based on visual
pin_spacing = 0.3 # Adjusted spacing based on visual

# Base positions of the pins
pin_base_positions = [
    # Row 1
    np.array([0.0, 0.0, 0.0]), # Pin 1 (at origin for simplicity)
    # # Row 2
    np.array([row_sep, pin_spacing / 2.0, 0.0]), # Pin 2
    np.array([row_sep, -pin_spacing / 2.0, 0.0]), # Pin 3
    # Row 3
    np.array([2 * row_sep, pin_spacing, 0.0]), # Pin 4
    np.array([2 * row_sep, 0.0, 0.0]), # Pin 5
    np.array([2 * row_sep, -pin_spacing, 0.0]), # Pin 6
    # Row 4
    np.array([3 * row_sep, pin_spacing * 1.5, 0.0]), # Pin 7
    np.array([3 * row_sep, pin_spacing * 0.5, 0.0]), # Pin 8
    np.array([3 * row_sep, -pin_spacing * 0.5, 0.0]), # Pin 9
    np.array([3 * row_sep, -pin_spacing * 1.5, 0.0]), # Pin 10
]

for i, base_pos in enumerate(pin_base_positions):
     # Adjust initial position so the CENTER OF MASS is at base_pos + [0, 0, height/3]
    initial_pin_cm_pos = base_pos + np.array([0.0, 0.0, pin_height / 3.0])
    pins.append(Pin(obj_id=f'pin_{i+1}',
                   pos=initial_pin_cm_pos, # This is the CM position
                   vel=np.array([0.0, 0.0, 0.0]),
                   quat=Quaternion.identity(),
                   ang_vel=np.array([0.0, 0.0, 0.0]),
                   radius=pin_radius,
                   height=pin_height,
                   mass=1.5))

# Combine all simulation objects
sim_objects = [ball_1] + pins

# --- Physics Engine ---

# Structure to hold derivatives for one object (not strictly necessary with RK45 state vector)
# class Derivatives:
#     def __init__(self):
#         self.d_pos = np.zeros(3)
#         self.d_vel = np.zeros(3)
#         self.d_quat = np.zeros(4) # Store as list/array for calculations
#         self.d_ang_vel = np.zeros(3)

def derivatives(t, y, mass, inv_inertia_world):
    """Calculates the time derivatives for the RK45 solver."""
    # Unpack state vector
    # pos = y[0:3] # Position is not needed for calculating derivatives of vel, quat, ang_vel
    vel = y[3:6]
    quat_list = y[6:10] # Quat as list
    ang_vel = y[10:13]

    # Convert quaternion list back to Quaternion object for operations
    quat = Quaternion(*quat_list)

    # Linear acceleration from forces
    acc = GRAVITY # Only gravity in this case

    # Angular acceleration from torques
    torque = np.zeros(3) # No external torques initially
    ang_acc = inv_inertia_world @ torque

    # Derivative of quaternion (from angular velocity)
    # dQ/dt = 0.5 * omega_quat * Q
    # omega_quat = [0, wx, wy, wz]
    omega_quat = Quaternion(0.0, *ang_vel)
    d_quat_obj = omega_quat * quat * 0.5 # Result is a Quaternion

    # Pack derivatives into a single vector
    dy = np.zeros(13)
    dy[0:3] = vel       # d(pos)/dt = vel
    dy[3:6] = acc       # d(vel)/dt = acc
    dy[6:10] = d_quat_obj.to_list() # d(quat)/dt
    dy[10:13] = ang_acc # d(ang_vel)/dt

    return dy



def pack_state(obj):
    """Packs object state into a numpy vector."""
    return np.concatenate([
        obj.pos,
        obj.vel,
        obj.quat.to_list(),
        obj.ang_vel
    ])

def rk45_step(obj, dt):
    """Performs one RK45 integration step for a rigid body."""
    y0 = pack_state(obj)
    t0 = 0.0
    t1 = dt

    # Pass mass and inverse inertia to the derivatives function
    rk = RK45(
        fun=lambda t, y: derivatives(t, y, obj.mass, obj.inv_inertia_world),
        t0=t0,
        y0=y0,
        t_bound=t1,
        max_step=dt # Allow RK45 to take steps up to dt
    )

    # Perform steps until t_bound (dt) is reached or exceeded
    while rk.t < t1:
        try:
            rk.step()
        except StopIteration:
            # This happens when t_bound is reached exactly
            break

    y_new = rk.y

    # Unpack the new state into the object
    obj.set_state_from_vector(y_new)


def check_and_resolve_collision(obj1, obj2):
    """ Checks and resolves collisions between two RigidBody objects. """
    obj2_pos, obj2_vel, obj2_q, obj2_ang_vel = obj2.pos, obj2.vel, obj2.quat, obj2.ang_vel
    obj1_pos, obj1_vel, obj1_q, obj1_ang_vel = obj1.pos, obj1.vel, obj1.quat, obj1.ang_vel

    vec_obj1_to_obj2 = obj2_pos - obj1_pos
    dist_centers_sq = np.dot(vec_obj1_to_obj2, vec_obj1_to_obj2)

    # Broad Phase
    bounding_radius_obj1 = np.sqrt(obj1.radius ** 2 + (obj1.height / 2) ** 2)
    min_dist_centers = obj2.radius + bounding_radius_obj1
    if dist_centers_sq > min_dist_centers ** 2:
        return  # Too far apart

    # Detailed Check
    obj1_z_axis_world = obj1_q.rotate_vector([0, 0, 1])
    obj1_y_axis_world = obj1_q.rotate_vector([0, 1, 0])
    obj1_x_axis_world = obj1_q.rotate_vector([1, 0, 0])

    proj_len = np.dot(vec_obj1_to_obj2, obj1_z_axis_world)
    closest_pt_on_axis = obj1_pos + proj_len * obj1_z_axis_world
    vec_axis_to_obj2 = obj2_pos - closest_pt_on_axis
    dist_axis_to_obj2_sq = np.dot(vec_axis_to_obj2, vec_axis_to_obj2)
    dist_axis_to_obj2 = np.sqrt(dist_axis_to_obj2_sq) if dist_axis_to_obj2_sq > 0 else 0
    is_within_height_range = abs(proj_len) <= obj1.height / 2.0
    # Use slightly tolerance for range check robustness
    radial_thresh = obj1.radius + obj2.radius
    is_within_radial_range = dist_axis_to_obj2 < radial_thresh + 1e-5

    is_within_cap_height_range = obj1.height / 2.0 < abs(proj_len) < obj1.height / 2.0 + obj2.radius + 1e-5
    is_radially_inside_cap_proj = dist_axis_to_obj2 < obj1.radius + 1e-5  # obj2 center needs to project inside obj1 radius

    collided = False
    penetration_depth = 0.0
    contact_normal = np.zeros(3)
    contact_point_obj2_local = np.zeros(3)
    contact_point_obj1_local = np.zeros(3)
    contact_point_obj1_world = np.zeros(3)  # Store world point for calc

    # Check Wall Collision
    if is_within_height_range and is_within_radial_range:
        penetration_candidate = radial_thresh - dist_axis_to_obj2
        if penetration_candidate > -1e-5:  # Allow very slight overlap before trigger
            if dist_axis_to_obj2 > 1e-6:
                contact_normal = vec_axis_to_obj2 / dist_axis_to_obj2
            else:  # obj2 center is on the obj1 axis - push radially
                contact_normal = obj1_x_axis_world if abs(np.dot(vec_obj1_to_obj2, obj1_x_axis_world)) > abs(
                    np.dot(vec_obj1_to_obj2, obj1_y_axis_world)) else obj1_y_axis_world

            penetration_depth = max(0, penetration_candidate)  # Ensure non-negative
            collided = True
            contact_point_obj2_local = -contact_normal * obj2.radius  # Relative to obj2 center
            contact_point_obj1_world = closest_pt_on_axis + contact_normal * obj1.radius  # On obj1 surface
            contact_point_obj1_local = obj1_q.conjugate().rotate_vector(contact_point_obj1_world - obj1_pos)
            # print(f"Wall Hit: depth={penetration_depth:.4f}")

    # Check Cap Collision (only if not already hit wall)
    # Use fixed cap contact point logic!
    if not collided and is_within_cap_height_range and is_radially_inside_cap_proj:
        penetration_candidate = obj2.radius - (abs(proj_len) - obj1.height / 2.0)
        if penetration_candidate > -1e-5:
            is_top_cap = proj_len > 0
            contact_normal = obj1_z_axis_world if is_top_cap else -obj1_z_axis_world
            penetration_depth = max(0, penetration_candidate)
            collided = True

            # --- Corrected Cap Contact Point ---
            cap_center_world = obj1_pos + obj1_z_axis_world * (obj1.height / 2.0 * np.sign(proj_len))
            # vec_axis_to_obj2 is the vector from axis to obj2 center (in cap plane)
            contact_point_obj1_world = cap_center_world + vec_axis_to_obj2
            # --- End Correction ---

            contact_point_obj2_local = -contact_normal * obj2.radius
            contact_point_obj1_local = obj1_q.conjugate().rotate_vector(contact_point_obj1_world - obj1_pos)
            # print(f"Cap Hit: depth={penetration_depth:.4f}")

    if not collided or penetration_depth <= 0:
        return  # No actual collision/penetration

    # --- Resolve Penetration (move objects apart based on mass) ---
    total_mass = obj2.mass + obj1.mass
    inv_total_mass = 1.0 / total_mass if total_mass > 1e-9 else 0
    move_fraction_obj2 = obj1.mass * inv_total_mass
    move_fraction_obj1 = obj2.mass * inv_total_mass

    # Correction factor slightly > 1 to ensure separation
    correction_factor = 1.01
    correction = contact_normal * penetration_depth * correction_factor
    obj2.pos += correction * move_fraction_obj2
    obj1.pos -= correction * move_fraction_obj1

    # --- Calculate Impulse (velocity change) ---
    r_obj2_world = obj2_q.rotate_vector(contact_point_obj2_local)  # Vector from obj2 CM to contact
    r_obj1_world = obj1_q.rotate_vector(contact_point_obj1_local)  # Vector from obj1 CM to contact

    v_contact_obj2 = obj2.vel + np.cross(obj2.ang_vel, r_obj2_world)
    v_contact_obj1 = obj1.vel + np.cross(obj1.ang_vel, r_obj1_world)
    v_relative = v_contact_obj2 - v_contact_obj1
    v_rel_normal = np.dot(v_relative, contact_normal)

    # If moving apart or resting, no impulse needed (vel already corrected by penetration push?)
    if v_rel_normal >= -1e-4:  # Small tolerance for resting contact separation
        return

    # Use already updated world inverse inertia tensors
    inv_I_obj2_world = obj2.inv_inertia_world
    inv_I_obj1_world = obj1.inv_inertia_world

    # Impulse calculation terms
    term_obj2_ang = np.cross(inv_I_obj2_world @ np.cross(r_obj2_world, contact_normal), r_obj2_world)
    term_obj1_ang = np.cross(inv_I_obj1_world @ np.cross(r_obj1_world, contact_normal), r_obj1_world)
    ang_impulse_term = np.dot(term_obj2_ang + term_obj1_ang, contact_normal)

    impulse_denom = obj2.inv_mass + obj1.inv_mass + ang_impulse_term

    if abs(impulse_denom) < 1e-9:
        print("Warning: Impulse denominator near zero. Skipping impulse.")
        return

    impulse_j = -(1.0 + COLLISION_EPSILON) * v_rel_normal / impulse_denom
    impulse_vector = impulse_j * contact_normal

    # --- Apply Impulse ---
    obj2.vel += impulse_vector * obj2.inv_mass
    obj1.vel -= impulse_vector * obj1.inv_mass

    obj2.ang_vel += inv_I_obj2_world @ np.cross(r_obj2_world, impulse_vector)
    obj1.ang_vel -= inv_I_obj1_world @ np.cross(r_obj1_world, impulse_vector)

def get_lowest_point_on_cylinder_analytical(quat_wxyz, position, radius, height, local_bottom_cap_z, local_top_cap_z):
    """
    Finds the lowest point on either the top or bottom circle of a cylinder
    in world space using an analytical approach, considering the CM is not
    at the geometric center.

    Args:
        quat_wxyz (np.array or list): The orientation of the cylinder as a
                                      quaternion in WXYZ format (scalar first).
        position (np.array or list): The position of the cylinder's CENTER OF MASS
                                in world space.
        radius (float): The radius of the cylinder's circular caps.
        height (float): The height of the cylinder. (Used for cap Z relative to CM)
        local_bottom_cap_z (float): The local Z coordinate of the bottom cap center relative to the CM.
        local_top_cap_z (float): The local Z coordinate of the top cap center relative to the CM.

    Returns:
        np.array: The world coordinates (x, y, z) of the lowest point on the
                  cylinder's caps.
    """
    # Ensure inputs are numpy arrays for efficient operations
    position = np.array(position)
    quat_wxyz = np.array(quat_wxyz)

    # Create a Rotation object from the quaternion (SciPy uses XYZW internally,
    # so we convert WXYZ to XYZW)
    quat_xyzw = np.array([quat_wxyz[1], quat_wxyz[2], quat_wxyz[3], quat_wxyz[0]])
    rotation = Rotation.from_quat(quat_xyzw)

    # World down direction
    world_down = np.array([0, 0, -1])

    # Rotate the world down direction into the cylinder's local coordinate system
    # This tells us which local direction corresponds to world down, relative to the CM.
    local_down = rotation.inv().apply(world_down)

    # The lowest point on a cap's circumference will be in the direction of
    # the projection of the local_down vector onto the local XY plane (where
    # the cap circles lie).
    local_down_projected_xy = np.array([local_down[0], local_down[1], 0])

    # Normalize the projected direction and scale by the radius.
    # Handle the case where the projection is zero (cylinder axis is vertical).
    norm_sq = np.sum(local_down_projected_xy**2)
    if norm_sq == 0:
        # Cylinder's local Z-axis is aligned with world Z-axis.
        # The lowest point on the cap is just the center of the cap.
        local_offset_radial = np.array([0, 0, 0])
    else:
        local_offset_direction = local_down_projected_xy / np.sqrt(norm_sq)
        local_offset_radial = radius * local_offset_direction


    # --- Calculate lowest point on the bottom cap ---
    # Local center of the bottom cap relative to CM
    bottom_cap_center_local_cm_origin = np.array([0, 0, local_bottom_cap_z])
    # Local point on the circumference corresponding to world down, relative to CM
    lowest_point_bottom_local_cm_origin = bottom_cap_center_local_cm_origin + local_offset_radial
    # Convert to world space (relative to CM world position)
    lowest_point_bottom_world = position + rotation.apply(lowest_point_bottom_local_cm_origin)

    # --- Calculate lowest point on the top cap ---
    # Local center of the top cap relative to CM
    top_cap_center_local_cm_origin = np.array([0, 0, local_top_cap_z])
    # Local point on the circumference corresponding to world down, relative to CM
    lowest_point_top_local_cm_origin = top_cap_center_local_cm_origin + local_offset_radial
    # Convert to world space (relative to CM world position)
    lowest_point_top_world = position + rotation.apply(lowest_point_top_local_cm_origin)


    # Compare the Z-coordinates in world space to find the overall lowest point
    if lowest_point_bottom_world[2] < lowest_point_top_world[2]:
        return lowest_point_bottom_world
    else:
        return lowest_point_top_world

# --- Floor Collision (Improved) ---
def resolve_floor_collisions(objects, dt):
    """Checks and resolves floor collisions for all objects in the list."""
    contact_normal = np.array([0.0, 0.0, 1.0])  # Floor normal points up

    for obj in objects:
        lowest_z_world = float('inf')
        contact_points_world = []

        # --- 1. Find Lowest Point(s) and Penetration ---
        if isinstance(obj, Ball):
            lowest_z_candidate = obj.pos[2] - obj.radius
            if lowest_z_candidate < lowest_z_world:
                lowest_z_world = lowest_z_candidate
            if lowest_z_world < 1e-5:  # Tolerance
                # Contact point is directly below the CM for sphere
                contact_points_world.append(obj.pos - contact_normal * obj.radius)

        elif isinstance(obj, Pin):
            # Use the helper function to find the lowest point on the pin's caps
            q = np.array(obj.quat.to_list())
            lowest_point = get_lowest_point_on_cylinder_analytical(
                quat_wxyz= q,
                position=obj.pos, # This is the CM position
                radius=obj.radius,
                height=obj.height,
                local_bottom_cap_z=obj.local_bottom_cap_z, # Pass new local Zs
                local_top_cap_z=obj.local_top_cap_z # Pass new local Zs
            )

            lowest_z_world = lowest_point[2]
            if lowest_z_world < 1e-5: # Tolerance
                 contact_points_world.append(lowest_point)

        if not contact_points_world or lowest_z_world >= -1e-5:  # No actual penetration below floor level
            continue

        # Average contact point if multiple vertices are penetrating (still valid for Ball)
        avg_contact_point_world = np.mean(contact_points_world, axis=0)
        # Penetration depth is the negative of the lowest Z world coordinate
        penetration_depth = max(0, -lowest_z_world) # Ensure non-negative

        # --- 2. Resolve Penetration ---
        # Move object up by the penetration depth along the floor normal
        # Ensure we don't overcorrect if already slightly above due to previous steps
        correction_factor = 1.01 # Move slightly more to ensure separation
        correction = contact_normal * penetration_depth * correction_factor
        obj.pos += correction

        # After moving the CM, the lowest point of the object should be at or above the floor.
        # Clamp the Z position as a failsafe against sinking.
        if isinstance(obj, Ball):
             # Lowest point is CM.z - radius
             if obj.pos[2] - obj.radius < -1e-6: # Still penetrating slightly?
                 obj.pos[2] = obj.radius # Place CM so lowest point is at Z=0
        elif isinstance(obj, Pin):
            # Recheck lowest point Z after correction
             q = np.array(obj.quat.to_list())
             current_lowest_point = get_lowest_point_on_cylinder_analytical(
                 quat_wxyz= q,
                 position=obj.pos, # Use updated CM position
                 radius=obj.radius,
                 height=obj.height,
                 local_bottom_cap_z=obj.local_bottom_cap_z,
                 local_top_cap_z=obj.local_top_cap_z
             )
             if current_lowest_point[2] < -1e-6: # Still penetrating slightly?
                 # Move CM up by the remaining penetration
                 obj.pos[2] += abs(current_lowest_point[2]) + 1e-4
                 # print(f"Warning: Floor penetration clamp needed for {obj.id}")
             if obj.ang_vel[2] > 0:
                 if np.power(np.e, -50/obj.ang_vel[2]) < obj.ang_vel[2]:
                    obj.ang_vel[2] = obj.ang_vel[2] - np.power(np.e, -50/obj.ang_vel[2])
                 else:
                    obj.ang_vel[2] = 50 * obj.ang_vel[2] / 51


        # --- 3. Calculate Normal Impulse (Bounce) ---
        r_world = avg_contact_point_world - obj.pos # Vector from CM to avg contact point

        v_contact = obj.vel + np.cross(obj.ang_vel, r_world)
        v_rel_normal = np.dot(v_contact, contact_normal) # Z-component relative to static floor

        impulse_j_normal = 0.0 # Initialize

        # Only apply bounce impulse if approaching floor significantly
        if v_rel_normal < -1e-3: # Velocity towards the floor
            # Use object's world inverse inertia tensor
            inv_I_world = obj.inv_inertia_world
            # Calculate the angular component of the impulse denominator
            term_ang = np.cross(inv_I_world @ np.cross(r_world, contact_normal), r_world)
            ang_impulse_term = np.dot(term_ang, contact_normal)
            impulse_denom = obj.inv_mass + ang_impulse_term

            if abs(impulse_denom) > 1e-9:
                if type(obj) == Ball:
                    impulse_j_normal = -(1.0 + FLOOR_RESTITUTION_BALL) * v_rel_normal / impulse_denom
                elif type(obj) == Pin:
                    impulse_j_normal = -(1.0 + FLOOR_RESTITUTION_PIN) * v_rel_normal / impulse_denom
                impulse_j_normal = max(0, impulse_j_normal) # Impulse must be non-negative (repulsive)
                impulse_vector_normal = impulse_j_normal * contact_normal

                # Apply normal impulse
                obj.vel += impulse_vector_normal * obj.inv_mass
                obj.ang_vel += inv_I_world @ np.cross(r_world, impulse_vector_normal)

        # --- 4. Calculate Friction Impulse (Rotation/Slowing) ---
        # Recalculate contact velocity *after* bounce impulse
        v_contact = obj.vel + np.cross(obj.ang_vel, r_world)
        v_tangential = v_contact - np.dot(v_contact, contact_normal) * contact_normal # Velocity component parallel to floor
        speed_tangential = np.linalg.norm(v_tangential)

        # Apply friction only if moving tangentially and there's contact force (either from gravity while resting/sliding or from bounce impulse)
        min_tangential_speed = 1e-3
        # Estimate Normal Force (N): Sum of force to counteract gravity and force from normal impulse
        normal_force_magnitude = abs(obj.mass * GRAVITY[2]) # Magnitude of force of gravity in Z
        # If there was a significant normal impulse, it implies a strong normal force
        if impulse_j_normal > 1e-6:
             # The force corresponding to the impulse over the timestep is Impulse / dt
             # This is a simplification; a more rigorous approach would consider forces integrated over time.
             # However, for a discrete-time simulation with instantaneous impulse, this is often used.
             normal_force_magnitude += impulse_j_normal / DT # Add the 'impact force' part

        # Calculate the maximum friction impulse magnitude based on Coulomb friction (mu * N * dt)
        # This is the maximum impulse that friction can apply over *this timestep*
        j_friction_max = FLOOR_FRICTION_COEFF * normal_force_magnitude * DT

        # Calculate the impulse magnitude needed to stop tangential motion in this step
        # The denominator is similar to the normal impulse denominator, but with the tangential direction
        if speed_tangential > min_tangential_speed and normal_force_magnitude > 1e-6: # Need tangential speed and contact force
             friction_dir = -v_tangential / speed_tangential # Opposite to tangential velocity
             inv_I_world = obj.inv_inertia_world

             term_ang_friction = np.cross(inv_I_world @ np.cross(r_world, friction_dir), r_world)
             ang_friction_term = np.dot(term_ang_friction, friction_dir)
             friction_denom = obj.inv_mass + ang_friction_term

             if abs(friction_denom) > 1e-9:
                  # Impulse magnitude needed to stop tangential motion
                  j_to_stop = speed_tangential / friction_denom

                  # Actual friction impulse is the smaller of the two (cannot exceed max, cannot overcorrect velocity)
                  impulse_j_friction = min(j_to_stop, j_friction_max)
                  impulse_j_friction = max(0, impulse_j_friction) # Must be non-negative magnitude
                  impulse_vector_friction = impulse_j_friction * friction_dir

                  # Apply friction impulse
                  obj.vel += impulse_vector_friction * obj.inv_mass
                  obj.ang_vel += inv_I_world @ np.cross(r_world, impulse_vector_friction)


# --- Visualization ---
fig = plt.figure(figsize=(12, 9))
ax = fig.add_subplot(111, projection='3d')
ax.set_aspect('equal', adjustable='box') # Try to make axes scale equally

# Pre-calculate unit sphere mesh points
u_sph, v_sph = np.mgrid[0:2 * np.pi:20j, 0:np.pi:10j]
x_sph_unit = np.cos(u_sph) * np.sin(v_sph)
y_sph_unit = np.sin(u_sph) * np.sin(v_sph)
z_sph_unit = np.cos(v_sph)

# Pre-calculate unit cylinder mesh points (relative to geometric center 0,0,0)
# These will be transformed based on the Pin's CM and height relative to CM for rendering
theta_cyl = np.linspace(0, 2 * np.pi, 20) # Reduced sides for performance
z_cyl_unit_geom = np.linspace(-0.5, 0.5, 8) # Unit Z for cylinder wall mesh
theta_cyl_grid, z_cyl_grid_unit_geom = np.meshgrid(theta_cyl, z_cyl_unit_geom)
x_cyl_unit = np.cos(theta_cyl_grid)
y_cyl_unit = np.sin(theta_cyl_grid)

# Caps (unit radius, unit Z at +/- 0.5 relative to geometric center)
r_cap_unit = np.linspace(0, 1, 5)
theta_cap_grid, r_cap_grid_unit = np.meshgrid(theta_cyl, r_cap_unit) # Reuse theta_cyl
x_cap_unit = r_cap_grid_unit * np.cos(theta_cap_grid)
y_cap_unit = r_cap_grid_unit * np.sin(theta_cap_grid)


# Dictionary to store plot artists for updating efficiently
plot_artists = {}

def init_visualization():
    """Create plot artists for all objects."""
    global plot_artists
    plot_artists = {} # Clear existing artists

    # Draw Ground Plane Static
    plot_limit_x = 2.0 # Increased range for 10 pins
    plot_limit_y = 1.0
    plot_limit_z = 1.0
    ax.set_xlim(-1.5, plot_limit_x) # Start behind ball
    ax.set_ylim(-plot_limit_y, plot_limit_y)
    ax.set_zlim(0, plot_limit_z) # Ensure Z starts from 0 (floor)
    ax.set_xlabel('X (m)')
    ax.set_ylabel('Y (m)')
    ax.set_zlabel('Z (m)')
    gx, gy = np.meshgrid(np.linspace(-1.5, plot_limit_x, 5), np.linspace(-plot_limit_y, plot_limit_y, 5))
    gz = np.zeros_like(gx)
    ax.plot_surface(gx, gy, gz, color='lightgrey', alpha=0.3, zorder=-1)

    # Create artists for each object
    for obj in sim_objects:
        if isinstance(obj, Ball):
            # Create ball surface plot
            # Initial position is already the CM
            surf = ax.plot_surface(x_sph_unit * obj.radius + obj.pos[0],
                                   y_sph_unit * obj.radius + obj.pos[1],
                                   z_sph_unit * obj.radius + obj.pos[2],
                                   color='darkblue', alpha=0.9)
            plot_artists[obj.id] = {'type': 'sphere', 'surface': surf}
        elif isinstance(obj, Pin):
            # Create pin surfaces (wall, top cap, bottom cap)
            # Initial positions and orientations will be updated in update_visualization
            wall_surf = ax.plot_surface(np.zeros_like(x_cyl_unit), np.zeros_like(y_cyl_unit), np.zeros_like(z_cyl_grid_unit_geom), color='red', alpha=0.7)
            top_cap_surf = ax.plot_surface(np.zeros_like(x_cap_unit), np.zeros_like(y_cap_unit), np.zeros_like(x_cap_unit), color='white', alpha=0.8)
            bottom_cap_surf = ax.plot_surface(np.zeros_like(x_cap_unit), np.zeros_like(y_cap_unit), np.zeros_like(x_cap_unit), color='darkred', alpha=0.8)
            plot_artists[obj.id] = {'type': 'cylinder', 'wall': wall_surf, 'top': top_cap_surf, 'bottom': bottom_cap_surf}

    # Return a list of all artists that will be updated
    # This is not strictly necessary for blit=False, but good practice
    all_artists = []
    for obj_id, artists in plot_artists.items():
        if artists['type'] == 'sphere':
            all_artists.append(artists['surface'])
        elif artists['type'] == 'cylinder':
            all_artists.extend([artists['wall'], artists['top'], artists['bottom']])
    return all_artists


def update_visualization(frame):
    """Updates the positions and orientations of plot artists."""
    ax.set_title(f'Bowling Simulation (Frame {frame}) DT={DT:.3f}')

    artists_to_return = [] # List to hold artists that have been updated

    for obj in sim_objects:
        obj_artists = plot_artists.get(obj.id)
        if not obj_artists: continue

        rot_matrix = obj.quat.to_rotation_matrix() # Rotation matrix from CM

        if obj_artists['type'] == 'sphere':
            surf = obj_artists['surface']
            # Calculate new coordinates relative to CM
            x_new = x_sph_unit * obj.radius + obj.pos[0]
            y_new = y_sph_unit * obj.radius + obj.pos[1]
            z_new = z_sph_unit * obj.radius + obj.pos[2]

            # Update surface data - Requires removing and re-adding surface for simplicity with matplotlib 3D
            surf.remove()
            new_surf = ax.plot_surface(x_new, y_new, z_new, color='darkblue', alpha=0.9)
            plot_artists[obj.id]['surface'] = new_surf # Store new artist
            artists_to_return.append(new_surf)


        elif obj_artists['type'] == 'cylinder':
            # Transform unit cylinder points to world space, relative to the CM (obj.pos)
            # Wall: Unit Z (-0.5 to 0.5) needs to map to local Z (-h/3 to 2h/3)
            # Mapping: local_z = (unit_z + 0.5) * height - height/3.0
            # local_z = unit_z * height + 0.5 * height - height/3.0
            # local_z = unit_z * height + height/6.0
            local_cyl_z_coords = z_cyl_grid_unit_geom * obj.height + obj.height/6.0

            cyl_points_local = np.vstack([
                (obj.radius * x_cyl_unit).flatten(),
                (obj.radius * y_cyl_unit).flatten(),
                local_cyl_z_coords.flatten() # Use adjusted local Z
            ])
            cyl_points_world = rot_matrix @ cyl_points_local + obj.pos[:, np.newaxis] # Transform from CM
            x_cyl = cyl_points_world[0, :].reshape(x_cyl_unit.shape)
            y_cyl = cyl_points_world[1, :].reshape(y_cyl_unit.shape)
            z_cyl = cyl_points_world[2, :].reshape(local_cyl_z_coords.shape)

            # Top Cap: Local Z = 2h/3 relative to CM
            cap_top_points_local = np.vstack([
                (obj.radius * x_cap_unit).flatten(),
                (obj.radius * y_cap_unit).flatten(),
                np.full(x_cap_unit.size, obj.local_top_cap_z) # Use stored local Z
            ])
            cap_top_points_world = rot_matrix @ cap_top_points_local + obj.pos[:, np.newaxis] # Transform from CM
            x_cap_top = cap_top_points_world[0, :].reshape(x_cap_unit.shape)
            y_cap_top = cap_top_points_world[1, :].reshape(y_cap_unit.shape)
            z_cap_top = cap_top_points_world[2, :].reshape(x_cap_unit.shape)

            # Bottom Cap: Local Z = -h/3 relative to CM
            cap_bottom_points_local = np.vstack([
                (obj.radius * x_cap_unit).flatten(),
                (obj.radius * y_cap_unit).flatten(),
                np.full(x_cap_unit.size, obj.local_bottom_cap_z) # Use stored local Z
            ])
            cap_bottom_points_world = rot_matrix @ cap_bottom_points_local + obj.pos[:, np.newaxis] # Transform from CM
            x_cap_bottom = cap_bottom_points_world[0, :].reshape(x_cap_unit.shape)
            y_cap_bottom = cap_bottom_points_world[1, :].reshape(y_cap_unit.shape)
            z_cap_bottom = cap_bottom_points_world[2, :].reshape(x_cap_unit.shape)

            # --- Update surfaces (remove and recreate) ---
            obj_artists['wall'].remove()
            obj_artists['top'].remove()
            obj_artists['bottom'].remove()

            new_wall = ax.plot_surface(x_cyl, y_cyl, z_cyl, color='red', alpha=0.7, linewidth=0.5, edgecolors='k')
            new_top = ax.plot_surface(x_cap_top, y_cap_top, z_cap_top, color='white', alpha=0.8)
            new_bottom = ax.plot_surface(x_cap_bottom, y_cap_bottom, z_cap_bottom, color='darkred', alpha=0.8)

            plot_artists[obj.id]['wall'] = new_wall
            plot_artists[obj.id]['top'] = new_top
            plot_artists[obj.id]['bottom'] = new_bottom
            artists_to_return.extend([new_wall, new_top, new_bottom])

    # Need to return all artists that might change - potentially complex
    # Returning the axes object is simpler for blit=False
    # return artists_to_return # If trying blit=True (might not work well)
    return ax, # Simpler approach for blit=False

# --- Pause/Play Controls ---
def pause(event):
    global is_paused
    is_paused = True
def play(event):
    global is_paused
    is_paused = False
ax_pause = plt.axes([0.7, 0.02, 0.1, 0.05])
ax_play = plt.axes([0.81, 0.02, 0.1, 0.05])
btn_pause = Button(ax_pause, 'Pause')
btn_play = Button(ax_play, 'Play')
btn_pause.on_clicked(pause)
btn_play.on_clicked(play)


# --- Main Simulation Loop (Update Function for Animation) ---
def update(frame):
    """Updates the animation frame"""
    # Declare that we are using the global variables sim_objects and is_paused
    global sim_objects, is_paused, ani # Add ani here as well for error handling

    if is_paused:
        # Need to return the artists for the animation to stay visible
        # When blit=False, returning the axes object is usually sufficient and safer.
        return ax,

    try:
        # --- Physics Steps ---
        # 1. Integrate motion for all objects
        for obj in sim_objects:
            rk45_step(obj, DT)
        # --- Collision Handling ---
        # 2. Check and resolve floor collisions first (stable base)
        resolve_floor_collisions(sim_objects, DT) # Pass the list

        # 3. Check and resolve object-object collisions
        for i in range(len(sim_objects)):
            for j in range(i + 1, len(sim_objects)):
                obj1 = sim_objects[i]
                obj2 = sim_objects[j]
                check_and_resolve_collision(obj1, obj2) # Modifies objects in place

        # --- Update Visualization ---

        return update_visualization(frame) # Call separate viz update

    except Exception as e:
        print(f"Error in frame {frame}:")
        traceback.print_exc()
        # Stop animation on error
        if 'ani' in globals() and ani and hasattr(ani, 'event_source') and ani.event_source:
            # Check if ani is defined and has event_source before trying to stop
             try:
                 ani.event_source.stop()
                 print("Animation stopped due to error.")
             except AttributeError:
                 print("Could not stop animation event source.")
        is_paused = True # Stop further updates by pausing
        return ax, # Return something to prevent further animation errors


# --- Run Animation ---
# Initialize visualization first to create artists
init_visualization()
for t in range(1):
    # --- Initial States & Objects ---
    ball_1 = Ball(obj_id='ball_1',
                  pos=np.array([-0.5, -0.065, 0.109]),  # Start touching floor (CM at radius)
                  vel=np.array([8,0, 0.0]),  # Faster initial speed
                  quat=Quaternion.identity(),
                  ang_vel=np.array([-8, 0.0, 0.0]),  # Maybe add initial spin later
                  radius=0.109,
                  mass=5.0)

    pins = []
    # Standard 10-pin setup (approximate positions relative to origin (0,0))
    # Distances are roughly: Row separation ~ sqrt(3)*PinDiam, Pin separation in row ~ 1.0*PinDiam
    pin_radius = 0.06
    pin_height = 0.38
    pin_diam = 2 * pin_radius
    row_sep = 0.3  # Adjusted spacing based on visual
    pin_spacing = 0.3  # Adjusted spacing based on visual

    # Base positions of the pins
    pin_base_positions = [
        # Row 1
        np.array([0.0, 0.0, 0.0]),  # Pin 1 (at origin for simplicity)
        # # Row 2
        np.array([row_sep, pin_spacing / 2.0, 0.0]),  # Pin 2
        np.array([row_sep, -pin_spacing / 2.0, 0.0]),  # Pin 3
        # Row 3
        np.array([2 * row_sep, pin_spacing, 0.0]),  # Pin 4
        np.array([2 * row_sep, 0.0, 0.0]),  # Pin 5
        np.array([2 * row_sep, -pin_spacing, 0.0]),  # Pin 6
        # Row 4
        np.array([3 * row_sep, pin_spacing * 1.5, 0.0]),  # Pin 7
        np.array([3 * row_sep, pin_spacing * 0.5, 0.0]),  # Pin 8
        np.array([3 * row_sep, -pin_spacing * 0.5, 0.0]),  # Pin 9
        np.array([3 * row_sep, -pin_spacing * 1.5, 0.0]),  # Pin 10
    ]

    for i, base_pos in enumerate(pin_base_positions):
        # Adjust initial position so the CENTER OF MASS is at base_pos + [0, 0, height/3]
        initial_pin_cm_pos = base_pos + np.array([0.0, 0.0, pin_height / 3.0])
        pins.append(Pin(obj_id=f'pin_{i + 1}',
                        pos=initial_pin_cm_pos,  # This is the CM position
                        vel=np.array([0.0, 0.0, 0.0]),
                        quat=Quaternion.identity(),
                        ang_vel=np.array([0.0, 0.0, 0.0]),
                        radius=pin_radius,
                        height=pin_height,
                        mass=1.5))

    # Combine all simulation objects
    sim_objects = [ball_1] + pins
    # x = []
    # for i in range(NUM_FRAMES):
    #     x.append(sim_objects[1].pos[0])
    #     update(i)
    fallen = []

    ani = animation.FuncAnimation(fig, update, frames=NUM_FRAMES,
                                  interval=max(1, int(DT * 1000)),
                                  blit=False, # Blit=True is hard with 3D surface updates
                                  repeat=False)
    for pin in sim_objects:
        if abs(pin.pos[2] - 0.12683664) > 0.004 and pin.obj_type == "cylinder":
            fallen.append(pin.id)
        # if pin.obj_type != "cylinder":
        #     print(pin.ang_vel)

    # print(t," fallen: ",fallen)
    print(t," total: ",len(fallen))
    plt.show()
    # plt.savefig(f'{0.01*t}_side.png')
# l = len(x)
# t = np.linspace(0, l*DT, l)
# plt.scatter(t,x)
# plt.show()

# plt.show()
print("Animation finished or window closed.")
